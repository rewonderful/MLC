#!/usr/bin/env python
# _*_ coding:utf-8 _*_
def diffWaysToCompute( input):
    """
    算法：分治
    思路：
            根据运算符的结合方式，就会产生多种不同的运算方式，由此想到将字符串以运算符分割，
        分割后的字符串又变成更小的含运算符的字符串，由此就可以看做是一种递归的分割模式，
        left --op-- right,left和right又是由subleft--subop--subright的子运算构成的，
        从而可以用分治的思想将字符串以运算符不断分割成更小的运算，直到左右都是单数字，这时候
        结合中间的运算符就可以进行计算了，然后递归向上组成原来问题的解。不同运算符的组合模式
        其实也就是子字符串采用不同位置的运算符对当前字符串进行分割罢了，如3-4*5，可以以减号"-"
        分割，得到(3)-(4*5)，也可以以乘号*分割得到(3-4)*(5)，因此可以在递归式子中添加for循环
        对不同位置的运算符分割进行尝试，要注意分割时保留当前的字符串状态，即向下传切片，这样回溯
        回来的时候，还能继续以当前字符串进行分割
        ---------------------------------------------------------------
                            2 * 3 - 4 * 5
                            /        \
              2 * (3 - 4 * 5)        ...
                        /     \
              (3 - 4 ) * 5     3 - (4 * 5)
               /    \
               3     4
        ---------------------------------------------------------------
        【注意】：
            这里要注意结果的返回形式，也是我debug了半天才看懂的模式，就是在程序中设置
        返回的结果列表res[]，并且在递归到将字符串分解为单个字符的时候，要将单个数字字符
        转化为单个数字的列表返回。这样做的原因是，对当前分割，如：
            （2）*（3-4*5）
            对于3-4*5事实上是有两种分割的，即(3)-(4*5)或者(3-4)*(5)，也就是说当3-4*5
        作为right的时候（left同理），其运算结果会是多个的，比如这里就是-17,-10,很自然的
        就应该用一个列表去存储它们，然后返回到上一级的时候，2作为left去乘*的，是两个元素，
        对应两种结果，而不是单一的结果。所以是两个for，对left和right的结果进行遍历分别
        用当前的operator去运算，并且返回当前即的left --op-- right的结果
            所以从这个角度看，"主函数"中调用该函数求解的过程可以看做更高一级的运算序列
        调用，将(2*3-4*5)整体看做了一个left or right。非常巧妙！
    复杂度分析：
        时间：不会算
        空间：不会算

    👉他人的思路分析：
    ----------------------------------------------------------------------------
    这道题使用分治策略进行解题。很关键的一点，每一个运算符都可以成为最后执行的那一个运算符，
    因此，以运算符为界，把字符串分为左右两个子字符串，分别求子字符串可能的结果，再将左右对
    应结果相乘，因为求子字符串的结果，与求原始字符串的结果是同样的问题，所以子字符串可以按
    同样的方式的分解，最后分解的边界是只有单个数字字符。 所以只要遍历一次字符串，分别以各个
    运算符为最后一个执行的运算符，算出可能的结果，最后返回所有计算出的结果就行。 需要注意的
    是字符串可能不包含运算符，这种情况相当于分解的边界情况
    ----------------------------------------------------------------------------
    这道题是使用分治策略，关键的一点是懂得怎么将原始问题分解为同样类型的子问题，
    因为原始问题是求字符串所有可能的运算顺序的结果，因此对问题进行分解的方向就是
    将原始字符串分为更小的子字符串，同时计算出分解的子字符串的结果能够用于求原始
    字符串的结果，结合每个运算符都会成为一次最后执行的运算符这一点就能得知分解的
    方式是以运算符为界进行划分
    ----------------------------------------------------------------------------
    """
    if input.isdigit():
        return [int(input)]
    res = []
    for i in range(len(input)):
        if input[i] in "-+*":
            left = diffWaysToCompute(input[:i])
            right = diffWaysToCompute(input[i + 1:])
            for l in left:
                for r in right:
                    if input[i] == '-': res.append(l - r)
                    if input[i] == '+': res.append(l + r)
                    if input[i] == '*': res.append(l * r)
    return res

if __name__ == '__main__':
    print(diffWaysToCompute("2*3-4*5"))