#!/usr/bin/env python
# _*_ coding:utf-8 _*_
def canJump(self, nums):
    """
    算法：贪心
        首先要明确如何向后跳是一个好的选择，从某个位置i向后跳的时候，可以选择的位置有nums[i]个（nums[i]存储
        了第i个位置可以向后跳的步数）。应当选择这nums[i]个位置中，又可以向后跳到最远位置的那个位置处：
            解释：
                譬如当前位置为i=0，可以向后跳3步，即从i=0出发最远可以到达j=0+3=3的位置，那么下一步如何跳要
                考察i+1,i+2,i+3这三个位置可以跳到的最远处，譬如这三个位置最远可达位置分别为4，6，3，那么
                下一步应该跳到i+2这个位置，因为这个位置可以到达位置i=6这里
        且若此时在i处，最远可达j，则一定可以到达i+1,i+2,...,j-1,j处

        解题：
            1. 建立"最远可达数组"，即i+nums[i]，求得nums中每个位置最远可达位置
            2. 设置curr=0起跳位置，以及当前最大可达位置max_reach，curr的意义就是逐个向后走，在最大可达
               位置内挪动，如i=0可达4，那么curr一定可以向后走到i=1,2,3,4。当curr走到i=1,2,3,4的途中，应该
               判断当前最大可达位置是否变大了，如果变大了就可以继续curr += 1一步一步向后走并更新最大可达位置
               （上面提过了，因为如果可以从i到达j，那么一定可以到i+1,i+2,...,j-1,j处，所以走到i处时，max_reach
               变了，就更新为更大的max_reach，curr++直到<=max_reach）
               所以可以设置curr记录当前到达位置，并且逐步向后移
            3. 令curr开始挪动，判断是否能抵达数组末尾，向下一个位置移动的条件是当前所在位置没有超过当前
               最大可达位置，并且curr当前位置应该是小于数组长度的
            4. 跳出循环后，curr记录的就是最后到达的位置，如果到达的位置就是数组末尾，也就是说在最大可达范围内
               一步一步走到了最后的数组末尾，则返回True否则False
        注意：
            我自己想的"解法"是，同样地也算出来reach数组记录每个位置能到达的最远位置，那么逐个遍历去判断数组
            内的最大可达位置是否有一个reach[x] >= len(nums)-1 的不就好了，即数组中有一个位置是到达该位置
            后一定可以到达数组末端的，但是！这样的想法忽略了【跳跃】的概念，即首先你得能到达那个可达数组末端
            的节点，如[1,1,0,0,999,999,1],因为中间有0，且前面的1，1不给力，虽然后面有999这种肯定能到达
            末端的位置，但是根本无法从i=0处跳到999，所以要用上面【解题】中的方法，在最大可达位置中curr += 1
        复杂度分析：
            时间：ON，建立辅助数组ON，curr挪动遍历一遍数组ON
            空间：ON，记录最大可达位置的辅助数组
    """
    if nums == []:
        return False
    reach = []
    for i in range(len(nums)):
        reach.append(i + nums[i])
    curr = 0
    max_reach = reach[0]
    while curr < len(nums) and curr <= max_reach:
        if reach[curr] > max_reach:
            max_reach = reach[curr]
        curr += 1
    return curr == len(nums)

def canJump_( nums):
    """
    算法：贪心2-逆向思维
            反过来思考整个跳跃的过程，如果能从某一个节点跳跃到达最后一个节点，那么从最后一个节点回看，一定能
        到达第一个初始节点。
    思路：
        如果有一条路径A->B->C->D->FINAL，即最后到达FINAL，那么从FINAL开始向前看，若D是能到达FINAL的，
        那么前面的位置只要能到达D就是到达FINAL的充分条件了，能到达D则一定能到达FINAL，倒着来看！

        所以倒着遍历数组，设置一个last位置为最后一个需要被前面位置可达的位置，从最后一个位置开始，last = FINAL，
        判断它的前一个节点pre的可达位置是否包括last位置，如果包括，即pre+nums[pre] >= last的话，就说明该pre节
        点可达last，更新last = pre，继续向后判断，看后面的节点可否达当前last，依次循环遍历，直到最后判断last == 0
        即最后一个需要可达的位置为初始节点

    """
    if nums == []:
        return False
    # 初始last是最后一个节点
    last = len(nums) - 1
    # 这里其实初始化为len(nums)-2,-1,-1 也是可以的，从倒数第二个节点开始判断是否可达倒数第一个节点，
    #但是从len(nums) - 1, -1, -1虽然冗余一次但是健壮性更好，譬如len(nums)=1时，1-2 = -1 不好
    #虽然提交了也AC了但是显然不健壮
    for i in range(len(nums) - 1, -1, -1):
        if i + nums[i] >= last:
            last = i
    return last == 0
if __name__ == '__main__':
    canJump([0])