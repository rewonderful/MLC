#!/usr/bin/env python
# _*_ coding:utf-8 _*_
def isMatch(self, s, p):
    """
    Solution Method
    算法:动规
    思路：
        动规的思路是在递归的"暴力"解法下启发的，暴力解法首先是将正则表达式匹配问题看成是比较两个字符串相互匹配
    的变种问题，就从头开始一个字符一个字符的去比较，在每次递归中对特殊字符.和*进行特殊的处理和判断，在递归匹配
    的过程中，如果某一步匹配失败了，那就回溯到上一次匹配成功的位置接着匹配
        动规就是对暴力递归的一种优化
        这里的动规数组dp是二维的，存储的dp[i][j]的含义是s的前i个字符与p的前j个字符是否匹配，存储bool值，
        dp的长度应该是len(s)+1,len(p)+1，因为代表的是前n个字符的情况而不是第ij个字符
            譬如abc的前2个字符的状态是在dp[2]里的，但是索引的时候是s[1]=b
        要注意*号和.的特殊性：
            1. 点儿 . 这个好说，任意字符就好了，不是很特殊
            2. 星号 * 这个麻烦，因为*号代表了0个或者多个，会让目标模式的字符长度不固定，但是有一点是要注意的
            那就是星号*一定不会单独出现，前面一定会有字符 _*
        ❗️❗️❗️：
            在一定程度上也正是因为星号的特殊性，所以从右向左建立递归，这样总是会先扫描到*号，以此来确定*号前这部分的
        长度是变长的，如果从左到右的话，某一个位置下一个位置才出现*就会使当前的判断变得棘手
            所以还是要注意不要很死板地一定从某个固定的方向看待问题，就像各种遍历，链表头插法一样，题目可能本身就隐含
        的次序问题，换个角度让次序成为帮助而不是阻碍，更好地利用问题本身的特征
        边界条件：
            1. dp[0][0] = True,即s的前0个字符，即空字符串和p的前0个字符模式，即空字符串是匹配的
            2. dp[0][j] 的状态，s是空串的时候，如果p具有类似于'x*'的结构，则是可以匹配的
                即if p[j-1] == '*': dp[0][j] = dp[0][j-2]
                如果p的第j个字符是通配符*号，则dp[0][j]应该取决于j的前面第2个位置的dp[0][j-2]，
        状态转移方程：
            1. 当s的当前末尾s[i-1]和p的当前末尾p[j-1]匹配时，即s[i-1] == p[j-1] or p[j-1] == '.'
                很显然dp[i][j] = dp[i-1][j-1]
            2.否则如果p的末尾p[j-1]是'*'的话，因为星号*一定不会单独出现，所以看其前一个位置p[j-2]的字符情况，
              相当于现在是这么个状态，小写s是当前字符串的最后一个字符，大写S是前面的字符串，p同理，现在要判断的就是
              s和p*的情况，小p就是p[j-2]了
                S   s
                P p *
              ------------
              A:
                如果不匹配，即p[i-2] != '.' and p[j-2] != s[i-1]:
                显然dp[i][j] = dp[i][j-2]，看看前i个字符和模式的j-2的情况
              B：
               二者匹配，即p[i-2] == '.' or p[j-2] == s[i-1]
               那么当前的这个a就要将情况划分成三种来看：当前匹配的a是P中的第0次，第1次还是第N次的a
               因为a*代表的就是三种，a要出现0次，1次，或者多次，所以现在就将这个a去按着三种划分并比较
               S   a
               P a *
              ------------
               S的a是模式中出现0次意义的a：
                    就相当于(S a) 与 P 匹配
                    dp[i][j] = dp[i][j-2]
               S的a是模式中出现1次意义的a：
                    相当于(S a) 与 (P a)匹配，
                    dp[i][j] = dp[i][j-1]
               S的a是模式中出现多次意义的a：
                    相当匹配的是 S a与P aaaaaa，则现在S中末尾的这个a出现前已经有若干个a出现了，那么匹配的
                关键就是S能和P aaaaaa匹配
                    dp[i][j] = dp[i-1][j]
    """
    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
    dp[0][0] = True
    for j in range(1, len(p) + 1):
        if p[j - 1] == '*' and dp[0][j - 2]:
            dp[0][j] = True
    for i in range(1, len(s) + 1):
        for j in range(1, len(p) + 1):
            if s[i - 1] == p[j - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                if p[j - 2] != '.' and p[j - 2] != s[i - 1]:
                    dp[i][j] = dp[i][j - 2]
                else:
                    dp[i][j] = dp[i][j - 2] or dp[i][j - 1] or dp[i - 1][j]
    return dp[-1][-1]