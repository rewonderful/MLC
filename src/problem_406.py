#!/usr/bin/env python
# _*_ coding:utf-8 _*_
def reconstructQueue(self, people):
    """
    Disscussion Method
    算法：贪心，

    先处理当前最高的人，因为最高的人前面除了和自己同高度的人，一定不会有更高的人在他前面，而且根据题意，决定
    一个人位置的关键在于比他高的人的情况，而比它矮的则不考虑，所以依次安排当前最高的人的站位，先排最高的人是合适的
    如现在有[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
    那么就先处理最高的7，并且处理7还不用考虑比它低的其他元素的站位
    [7,0],[7,1]
    相同元素按[h,k]的k来排列
    剩余元素[ [4,4], [5,0], [6,1], [5,2]]
    排[6,1]，对6来说，比它高的已经排好了，已经排好的序列就是比它高的所有元素的序列，那么此时[6,1]中的第二项，其实就
    已经标明了[6,1]在这次序列排序中应该在的位置，所以将[6,1]【插入】到它应该在的位置处
    [7,0],[6,1],[7,1]
    剩余元素[ [4,4], [5,0], [5,2]]，最高的是[5,0], [5,2]
    对5来说也是一样，当前的result已经是排好的比它高的所有序列情况了，那么[5,0]和 [5,2]根据k插入到它应该在的位置
    [5,0]，[7,0],[5,2]，[6,1],[7,1]
    最后剩下[4,4]，同样前面都是比4高的了，此时的k标明4应该在的位置，插入
    [5,0]，[7,0],[5,2]，[6,1],[4,4],[7,1]
    完成
    """
    people.sort(key=lambda x: (-x[0], x[1]))
    result = []
    for p in people:
        result.insert(p[1], p)
    return result
